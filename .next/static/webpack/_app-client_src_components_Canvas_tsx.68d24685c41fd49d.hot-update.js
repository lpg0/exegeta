"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-client_src_components_Canvas_tsx",{

/***/ "(app-client)/./src/components/nodes/TextNode.tsx":
/*!*******************************************!*\
  !*** ./src/components/nodes/TextNode.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(app-client)/./node_modules/react-konva/es/ReactKonva.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst TextNode = (param)=>{\n    let { node , onSelect , onDragEnd , onTextChange  } = param;\n    _s();\n    const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const clickTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textAreaElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"TextNode \".concat(node.id, \": Single click detected, isEditing:\"), isEditing);\n        if (isEditing) return;\n        // Clear any existing timeout\n        if (clickTimeoutRef.current) {\n            clearTimeout(clickTimeoutRef.current);\n            clickTimeoutRef.current = null;\n        }\n        // Set a timeout for single click action\n        clickTimeoutRef.current = setTimeout(()=>{\n            console.log(\"TextNode \".concat(node.id, \": Processing single click\"));\n            onSelect === null || onSelect === void 0 ? void 0 : onSelect(node.id);\n        }, 200);\n    }, [\n        node.id,\n        isEditing,\n        onSelect\n    ]);\n    const handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        console.log(\"TextNode \".concat(node.id, \": Drag end detected\"));\n        if (isEditing) return;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(node.id, e.target.x(), e.target.y());\n    }, [\n        node.id,\n        isEditing,\n        onDragEnd\n    ]);\n    const createTextArea = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const textNode = textRef.current;\n        if (!textNode) return null;\n        const stage = textNode.getStage();\n        const container = stage === null || stage === void 0 ? void 0 : stage.container();\n        if (!stage || !container) return null;\n        // Get the bounding rect of the canvas container\n        const containerRect = container.getBoundingClientRect();\n        // Get the absolute position of the text node\n        const absPos = textNode.getAbsolutePosition();\n        const scale = stage.scaleX();\n        // Calculate the actual position relative to the page\n        const x = containerRect.left + absPos.x * scale;\n        const y = containerRect.top + absPos.y * scale;\n        const width = (node.width || textNode.width() || 100) * scale;\n        const height = (node.height || textNode.height() || 20) * scale;\n        // Create textarea element\n        const textarea = document.createElement(\"textarea\");\n        textarea.value = node.text;\n        textarea.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(x, \"px;\\n      top: \").concat(y, \"px;\\n      width: \").concat(width, \"px;\\n      height: \").concat(height, \"px;\\n      font-size: \").concat((node.fontSize || 16) * scale, \"px;\\n      font-family: \").concat(node.fontFamily || \"Arial\", \";\\n      color: \").concat(node.fill || \"#000000\", \";\\n      border: 2px solid #007bff;\\n      padding: 2px;\\n      margin: 0px;\\n      overflow: hidden;\\n      background: white;\\n      outline: none;\\n      resize: none;\\n      line-height: 1.2;\\n      z-index: 1000;\\n      white-space: pre-wrap;\\n      word-break: break-word;\\n      box-sizing: border-box;\\n    \");\n        // Add event listeners\n        const handleKeyDown = (e)=>{\n            e.stopPropagation();\n            if (e.key === \"Enter\" && !e.shiftKey) {\n                e.preventDefault();\n                commitTextChange();\n            }\n            if (e.key === \"Escape\") {\n                cancelEdit();\n            }\n        };\n        const handleBlur = ()=>{\n            // Small delay to prevent immediate blur\n            setTimeout(()=>{\n                if (document.body.contains(textarea)) {\n                    commitTextChange();\n                }\n            }, 100);\n        };\n        const commitTextChange = ()=>{\n            const newText = textarea.value;\n            if (onTextChange && newText !== node.text) {\n                onTextChange(node.id, newText);\n            }\n            cleanupTextArea();\n        };\n        const cancelEdit = ()=>{\n            cleanupTextArea();\n        };\n        const cleanupTextArea = ()=>{\n            if (textarea.parentNode) {\n                textarea.parentNode.removeChild(textarea);\n            }\n            textAreaElementRef.current = null;\n            setIsEditing(false);\n            if (textRef.current) {\n                textRef.current.draggable(true);\n            }\n        };\n        textarea.addEventListener(\"keydown\", handleKeyDown);\n        textarea.addEventListener(\"blur\", handleBlur);\n        // Store reference for cleanup\n        textAreaElementRef.current = textarea;\n        return textarea;\n    }, [\n        node,\n        onTextChange\n    ]);\n    const handleDoubleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"TextNode \".concat(node.id, \": Double click detected, starting edit mode\"));\n        // Clear single click timeout\n        if (clickTimeoutRef.current) {\n            clearTimeout(clickTimeoutRef.current);\n            clickTimeoutRef.current = null;\n        }\n        // Clean up any existing textarea\n        if (textAreaElementRef.current) {\n            if (textAreaElementRef.current.parentNode) {\n                textAreaElementRef.current.parentNode.removeChild(textAreaElementRef.current);\n            }\n            textAreaElementRef.current = null;\n        }\n        setIsEditing(true);\n        // Disable dragging\n        if (textRef.current) {\n            textRef.current.draggable(false);\n        }\n        // Create and show textarea\n        const textarea = createTextArea();\n        if (textarea) {\n            document.body.appendChild(textarea);\n            // Focus and select after a brief delay\n            setTimeout(()=>{\n                textarea.focus();\n                textarea.select();\n            }, 10);\n        }\n    }, [\n        node.id,\n        createTextArea\n    ]);\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (textAreaElementRef.current && textAreaElementRef.current.parentNode) {\n                textAreaElementRef.current.parentNode.removeChild(textAreaElementRef.current);\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Text, {\n        ref: textRef,\n        id: node.id,\n        x: node.x,\n        y: node.y,\n        text: node.text,\n        fontSize: node.fontSize || 16,\n        fontFamily: node.fontFamily || \"Arial\",\n        fill: node.fill || \"#000000\",\n        width: node.width,\n        height: node.height,\n        draggable: !isEditing,\n        opacity: isEditing ? 0.3 : 1,\n        onClick: handleClick,\n        onTap: handleClick,\n        onDblClick: handleDoubleClick,\n        onDragEnd: handleDragEnd,\n        stroke: node.selected ? \"#007bff\" : undefined,\n        strokeWidth: node.selected ? 2 : 0,\n        listening: !isEditing\n    }, void 0, false, {\n        fileName: \"/Users/lukegiraudeau/dev/exegeta/src/components/nodes/TextNode.tsx\",\n        lineNumber: 192,\n        columnNumber: 5\n    }, undefined);\n};\n_s(TextNode, \"rkrXUVXpnWyMjXJTTA4qic4vcfs=\");\n_c = TextNode;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TextNode);\nvar _c;\n$RefreshReg$(_c, \"TextNode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2NvbXBvbmVudHMvbm9kZXMvVGV4dE5vZGUudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7QUFDckM7QUFXbkMsTUFBTU0sV0FBb0M7UUFBQyxFQUFFQyxLQUFJLEVBQUVDLFNBQVEsRUFBRUMsVUFBUyxFQUFFQyxhQUFZLEVBQUU7O0lBQ3BGLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHWCwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNWSxVQUFVWCw2Q0FBTUEsQ0FBYTtJQUNuQyxNQUFNWSxrQkFBa0JaLDZDQUFNQSxDQUF3QjtJQUN0RCxNQUFNYSxxQkFBcUJiLDZDQUFNQSxDQUE2QjtJQUU5RCxNQUFNYyxjQUFjWixrREFBV0EsQ0FBQztRQUM5QmEsUUFBUUMsSUFBSSxZQUFvQixPQUFSWCxLQUFLWSxJQUFHLHdDQUFzQ1I7UUFDdEUsSUFBSUEsV0FBVztRQUVmLDZCQUE2QjtRQUM3QixJQUFJRyxnQkFBZ0JNLFNBQVM7WUFDM0JDLGFBQWFQLGdCQUFnQk07WUFDN0JOLGdCQUFnQk0sVUFBVTtRQUM1QjtRQUVBLHdDQUF3QztRQUN4Q04sZ0JBQWdCTSxVQUFVRSxXQUFXO1lBQ25DTCxRQUFRQyxJQUFJLFlBQW9CLE9BQVJYLEtBQUtZLElBQUc7WUFDaENYLHFCQUFBQSxzQkFBQUEsS0FBQUEsSUFBQUEsU0FBV0QsS0FBS1k7UUFDbEIsR0FBRztJQUNMLEdBQUc7UUFBQ1osS0FBS1k7UUFBSVI7UUFBV0g7S0FBUztJQUVqQyxNQUFNZSxnQkFBZ0JuQixrREFBV0EsQ0FBQyxDQUFDb0I7UUFDakNQLFFBQVFDLElBQUksWUFBb0IsT0FBUlgsS0FBS1ksSUFBRztRQUNoQyxJQUFJUixXQUFXO1FBQ2ZGLHNCQUFBQSx1QkFBQUEsS0FBQUEsSUFBQUEsVUFBWUYsS0FBS1ksSUFBSUssRUFBRUMsT0FBT0MsS0FBS0YsRUFBRUMsT0FBT0U7SUFDOUMsR0FBRztRQUFDcEIsS0FBS1k7UUFBSVI7UUFBV0Y7S0FBVTtJQUVsQyxN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UUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9ub2Rlcy9UZXh0Tm9kZS50c3g/OTE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdyZWFjdC1rb252YSc7XG5pbXBvcnQgeyBUZXh0Tm9kZSBhcyBUZXh0Tm9kZVR5cGUgfSBmcm9tICdAL3R5cGVzL25vZGVzJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmludGVyZmFjZSBUZXh0Tm9kZVByb3BzIHtcbiAgbm9kZTogVGV4dE5vZGVUeXBlO1xuICBvblNlbGVjdD86IChub2RlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgb25EcmFnRW5kPzogKG5vZGVJZDogc3RyaW5nLCB4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gdm9pZDtcbiAgb25UZXh0Q2hhbmdlPzogKG5vZGVJZDogc3RyaW5nLCBuZXdUZXh0OiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFRleHROb2RlOiBSZWFjdC5GQzxUZXh0Tm9kZVByb3BzPiA9ICh7IG5vZGUsIG9uU2VsZWN0LCBvbkRyYWdFbmQsIG9uVGV4dENoYW5nZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0VkaXRpbmcsIHNldElzRWRpdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHRleHRSZWYgPSB1c2VSZWY8S29udmEuVGV4dD4obnVsbCk7XG4gIGNvbnN0IGNsaWNrVGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCB0ZXh0QXJlYUVsZW1lbnRSZWYgPSB1c2VSZWY8SFRNTFRleHRBcmVhRWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBTaW5nbGUgY2xpY2sgZGV0ZWN0ZWQsIGlzRWRpdGluZzpgLCBpc0VkaXRpbmcpO1xuICAgIGlmIChpc0VkaXRpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxuICAgIGlmIChjbGlja1RpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNsaWNrVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsaWNrVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IGEgdGltZW91dCBmb3Igc2luZ2xlIGNsaWNrIGFjdGlvblxuICAgIGNsaWNrVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgVGV4dE5vZGUgJHtub2RlLmlkfTogUHJvY2Vzc2luZyBzaW5nbGUgY2xpY2tgKTtcbiAgICAgIG9uU2VsZWN0Py4obm9kZS5pZCk7XG4gICAgfSwgMjAwKTtcbiAgfSwgW25vZGUuaWQsIGlzRWRpdGluZywgb25TZWxlY3RdKTtcblxuICBjb25zdCBoYW5kbGVEcmFnRW5kID0gdXNlQ2FsbGJhY2soKGU6IEtvbnZhLktvbnZhRXZlbnRPYmplY3Q8RHJhZ0V2ZW50PikgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBEcmFnIGVuZCBkZXRlY3RlZGApO1xuICAgIGlmIChpc0VkaXRpbmcpIHJldHVybjtcbiAgICBvbkRyYWdFbmQ/Lihub2RlLmlkLCBlLnRhcmdldC54KCksIGUudGFyZ2V0LnkoKSk7XG4gIH0sIFtub2RlLmlkLCBpc0VkaXRpbmcsIG9uRHJhZ0VuZF0pO1xuXG4gIGNvbnN0IGNyZWF0ZVRleHRBcmVhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gdGV4dFJlZi5jdXJyZW50O1xuICAgIGlmICghdGV4dE5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3Qgc3RhZ2UgPSB0ZXh0Tm9kZS5nZXRTdGFnZSgpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN0YWdlPy5jb250YWluZXIoKTtcbiAgICBcbiAgICBpZiAoIXN0YWdlIHx8ICFjb250YWluZXIpIHJldHVybiBudWxsO1xuXG4gICAgLy8gR2V0IHRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjYW52YXMgY29udGFpbmVyXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IG5vZGVcbiAgICBjb25zdCBhYnNQb3MgPSB0ZXh0Tm9kZS5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc2NhbGUgPSBzdGFnZS5zY2FsZVgoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFnZVxuICAgIGNvbnN0IHggPSBjb250YWluZXJSZWN0LmxlZnQgKyBhYnNQb3MueCAqIHNjYWxlO1xuICAgIGNvbnN0IHkgPSBjb250YWluZXJSZWN0LnRvcCArIGFic1Bvcy55ICogc2NhbGU7XG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSAobm9kZS53aWR0aCB8fCB0ZXh0Tm9kZS53aWR0aCgpIHx8IDEwMCkgKiBzY2FsZTtcbiAgICBjb25zdCBoZWlnaHQgPSAobm9kZS5oZWlnaHQgfHwgdGV4dE5vZGUuaGVpZ2h0KCkgfHwgMjApICogc2NhbGU7XG5cbiAgICAvLyBDcmVhdGUgdGV4dGFyZWEgZWxlbWVudFxuICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0ZXh0YXJlYS52YWx1ZSA9IG5vZGUudGV4dDtcbiAgICB0ZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHt4fXB4O1xuICAgICAgdG9wOiAke3l9cHg7XG4gICAgICB3aWR0aDogJHt3aWR0aH1weDtcbiAgICAgIGhlaWdodDogJHtoZWlnaHR9cHg7XG4gICAgICBmb250LXNpemU6ICR7KG5vZGUuZm9udFNpemUgfHwgMTYpICogc2NhbGV9cHg7XG4gICAgICBmb250LWZhbWlseTogJHtub2RlLmZvbnRGYW1pbHkgfHwgJ0FyaWFsJ307XG4gICAgICBjb2xvcjogJHtub2RlLmZpbGwgfHwgJyMwMDAwMDAnfTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkICMwMDdiZmY7XG4gICAgICBwYWRkaW5nOiAycHg7XG4gICAgICBtYXJnaW46IDBweDtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICByZXNpemU6IG5vbmU7XG4gICAgICBsaW5lLWhlaWdodDogMS4yO1xuICAgICAgei1pbmRleDogMTAwMDtcbiAgICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGA7XG5cbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgXG4gICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb21taXRUZXh0Q2hhbmdlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIGNhbmNlbEVkaXQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIHByZXZlbnQgaW1tZWRpYXRlIGJsdXJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyh0ZXh0YXJlYSkpIHtcbiAgICAgICAgICBjb21taXRUZXh0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbW1pdFRleHRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gdGV4dGFyZWEudmFsdWU7XG4gICAgICBpZiAob25UZXh0Q2hhbmdlICYmIG5ld1RleHQgIT09IG5vZGUudGV4dCkge1xuICAgICAgICBvblRleHRDaGFuZ2Uobm9kZS5pZCwgbmV3VGV4dCk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwVGV4dEFyZWEoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2FuY2VsRWRpdCA9ICgpID0+IHtcbiAgICAgIGNsZWFudXBUZXh0QXJlYSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBjbGVhbnVwVGV4dEFyZWEgPSAoKSA9PiB7XG4gICAgICBpZiAodGV4dGFyZWEucGFyZW50Tm9kZSkge1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRhcmVhKTtcbiAgICAgIH1cbiAgICAgIHRleHRBcmVhRWxlbWVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzRWRpdGluZyhmYWxzZSk7XG4gICAgICBpZiAodGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHRleHRSZWYuY3VycmVudC5kcmFnZ2FibGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICB0ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG5cbiAgICAvLyBTdG9yZSByZWZlcmVuY2UgZm9yIGNsZWFudXBcbiAgICB0ZXh0QXJlYUVsZW1lbnRSZWYuY3VycmVudCA9IHRleHRhcmVhO1xuXG4gICAgcmV0dXJuIHRleHRhcmVhO1xuICB9LCBbbm9kZSwgb25UZXh0Q2hhbmdlXSk7XG5cbiAgY29uc3QgaGFuZGxlRG91YmxlQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IERvdWJsZSBjbGljayBkZXRlY3RlZCwgc3RhcnRpbmcgZWRpdCBtb2RlYCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgc2luZ2xlIGNsaWNrIHRpbWVvdXRcbiAgICBpZiAoY2xpY2tUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGlja1RpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGFueSBleGlzdGluZyB0ZXh0YXJlYVxuICAgIGlmICh0ZXh0QXJlYUVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgaWYgKHRleHRBcmVhRWxlbWVudFJlZi5jdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGV4dEFyZWFFbGVtZW50UmVmLmN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0QXJlYUVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0ZXh0QXJlYUVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHNldElzRWRpdGluZyh0cnVlKTtcbiAgICBcbiAgICAvLyBEaXNhYmxlIGRyYWdnaW5nXG4gICAgaWYgKHRleHRSZWYuY3VycmVudCkge1xuICAgICAgdGV4dFJlZi5jdXJyZW50LmRyYWdnYWJsZShmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhbmQgc2hvdyB0ZXh0YXJlYVxuICAgIGNvbnN0IHRleHRhcmVhID0gY3JlYXRlVGV4dEFyZWEoKTtcbiAgICBpZiAodGV4dGFyZWEpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dGFyZWEpO1xuICAgICAgXG4gICAgICAvLyBGb2N1cyBhbmQgc2VsZWN0IGFmdGVyIGEgYnJpZWYgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0ZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH0sIFtub2RlLmlkLCBjcmVhdGVUZXh0QXJlYV0pO1xuXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGV4dEFyZWFFbGVtZW50UmVmLmN1cnJlbnQgJiYgdGV4dEFyZWFFbGVtZW50UmVmLmN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0ZXh0QXJlYUVsZW1lbnRSZWYuY3VycmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRBcmVhRWxlbWVudFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8VGV4dFxuICAgICAgcmVmPXt0ZXh0UmVmfVxuICAgICAgaWQ9e25vZGUuaWR9XG4gICAgICB4PXtub2RlLnh9XG4gICAgICB5PXtub2RlLnl9XG4gICAgICB0ZXh0PXtub2RlLnRleHR9XG4gICAgICBmb250U2l6ZT17bm9kZS5mb250U2l6ZSB8fCAxNn1cbiAgICAgIGZvbnRGYW1pbHk9e25vZGUuZm9udEZhbWlseSB8fCAnQXJpYWwnfVxuICAgICAgZmlsbD17bm9kZS5maWxsIHx8ICcjMDAwMDAwJ31cbiAgICAgIHdpZHRoPXtub2RlLndpZHRofVxuICAgICAgaGVpZ2h0PXtub2RlLmhlaWdodH1cbiAgICAgIGRyYWdnYWJsZT17IWlzRWRpdGluZ31cbiAgICAgIG9wYWNpdHk9e2lzRWRpdGluZyA/IDAuMyA6IDF9XG4gICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgIG9uVGFwPXtoYW5kbGVDbGlja31cbiAgICAgIG9uRGJsQ2xpY2s9e2hhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgb25EcmFnRW5kPXtoYW5kbGVEcmFnRW5kfVxuICAgICAgc3Ryb2tlPXtub2RlLnNlbGVjdGVkID8gJyMwMDdiZmYnIDogdW5kZWZpbmVkfVxuICAgICAgc3Ryb2tlV2lkdGg9e25vZGUuc2VsZWN0ZWQgPyAyIDogMH1cbiAgICAgIGxpc3RlbmluZz17IWlzRWRpdGluZ31cbiAgICAvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dE5vZGU7ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJUZXh0IiwiVGV4dE5vZGUiLCJub2RlIiwib25TZWxlY3QiLCJvbkRyYWdFbmQiLCJvblRleHRDaGFuZ2UiLCJpc0VkaXRpbmciLCJzZXRJc0VkaXRpbmciLCJ0ZXh0UmVmIiwiY2xpY2tUaW1lb3V0UmVmIiwidGV4dEFyZWFFbGVtZW50UmVmIiwiaGFuZGxlQ2xpY2siLCJjb25zb2xlIiwibG9nIiwiaWQiLCJjdXJyZW50IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImhhbmRsZURyYWdFbmQiLCJlIiwidGFyZ2V0IiwieCIsInkiLCJjcmVhdGVUZXh0QXJlYSIsInRleHROb2RlIiwic3RhZ2UiLCJnZXRTdGFnZSIsImNvbnRhaW5lciIsImNvbnRhaW5lclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJhYnNQb3MiLCJnZXRBYnNvbHV0ZVBvc2l0aW9uIiwic2NhbGUiLCJzY2FsZVgiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJ0ZXh0YXJlYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInZhbHVlIiwidGV4dCIsInN0eWxlIiwiY3NzVGV4dCIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImZpbGwiLCJoYW5kbGVLZXlEb3duIiwic3RvcFByb3BhZ2F0aW9uIiwia2V5Iiwic2hpZnRLZXkiLCJwcmV2ZW50RGVmYXVsdCIsImNvbW1pdFRleHRDaGFuZ2UiLCJjYW5jZWxFZGl0IiwiaGFuZGxlQmx1ciIsImJvZHkiLCJjb250YWlucyIsIm5ld1RleHQiLCJjbGVhbnVwVGV4dEFyZWEiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkcmFnZ2FibGUiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJhcHBlbmRDaGlsZCIsImZvY3VzIiwic2VsZWN0IiwicmVmIiwib3BhY2l0eSIsIm9uQ2xpY2siLCJvblRhcCIsIm9uRGJsQ2xpY2siLCJzdHJva2UiLCJzZWxlY3RlZCIsInVuZGVmaW5lZCIsInN0cm9rZVdpZHRoIiwibGlzdGVuaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./src/components/nodes/TextNode.tsx\n"));

/***/ })

});