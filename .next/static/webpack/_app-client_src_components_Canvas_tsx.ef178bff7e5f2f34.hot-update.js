"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-client_src_components_Canvas_tsx",{

/***/ "(app-client)/./src/components/nodes/TextNode.tsx":
/*!*******************************************!*\
  !*** ./src/components/nodes/TextNode.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-konva */ \"(app-client)/./node_modules/react-konva/es/ReactKonva.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst TextNode = (param)=>{\n    let { node , onSelect , onDragEnd , onTextChange  } = param;\n    _s();\n    const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [editText, setEditText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(node.text);\n    const textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textAreaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const clickTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const [portalContainer, setPortalContainer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Track component mount state and set up portal container\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        mountedRef.current = true;\n        // Ensure we have access to document.body\n        if (typeof document !== \"undefined\") {\n            setPortalContainer(document.body);\n        }\n        return ()=>{\n            mountedRef.current = false;\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"TextNode \".concat(node.id, \": isEditing changed to\"), isEditing);\n        if (isEditing && mountedRef.current) {\n            // Use a longer timeout to ensure the textarea is fully rendered\n            const timeoutId = setTimeout(()=>{\n                if (!mountedRef.current) return;\n                console.log(\"TextNode \".concat(node.id, \": Attempting to focus textarea\"));\n                if (textAreaRef.current && typeof textAreaRef.current.focus === \"function\") {\n                    textAreaRef.current.focus();\n                    textAreaRef.current.select();\n                    console.log(\"TextNode \".concat(node.id, \": Textarea focused successfully\"));\n                } else {\n                    console.log(\"TextNode \".concat(node.id, \": Textarea ref not available or focus not a function\"));\n                }\n            }, 100);\n            return ()=>clearTimeout(timeoutId);\n        }\n    }, [\n        isEditing,\n        node.id\n    ]);\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"TextNode \".concat(node.id, \": Single click detected, isEditing:\"), isEditing);\n        if (isEditing || !mountedRef.current) return;\n        // Clear any existing timeout\n        if (clickTimeoutRef.current) {\n            clearTimeout(clickTimeoutRef.current);\n            clickTimeoutRef.current = null;\n        }\n        // Set a timeout for single click action\n        clickTimeoutRef.current = setTimeout(()=>{\n            if (!mountedRef.current) return;\n            console.log(\"TextNode \".concat(node.id, \": Processing single click\"));\n            onSelect === null || onSelect === void 0 ? void 0 : onSelect(node.id);\n        }, 200);\n    }, [\n        node.id,\n        isEditing,\n        onSelect\n    ]);\n    const handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        console.log(\"TextNode \".concat(node.id, \": Drag end detected\"));\n        if (isEditing || !mountedRef.current) return;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(node.id, e.target.x(), e.target.y());\n    }, [\n        node.id,\n        isEditing,\n        onDragEnd\n    ]);\n    const handleDoubleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        console.log(\"TextNode \".concat(node.id, \": Double click detected, starting edit mode\"));\n        if (!mountedRef.current) {\n            console.log(\"TextNode \".concat(node.id, \": Component not mounted, skipping edit mode\"));\n            return;\n        }\n        // Clear single click timeout\n        if (clickTimeoutRef.current) {\n            clearTimeout(clickTimeoutRef.current);\n            clickTimeoutRef.current = null;\n        }\n        try {\n            setEditText(node.text); // Initialize with current text\n            setIsEditing(true);\n            // Temporarily disable dragging on the Konva.Text node itself\n            if (textRef.current) {\n                textRef.current.draggable(false);\n            }\n        } catch (error) {\n            console.error(\"TextNode \".concat(node.id, \": Error setting edit mode:\"), error);\n        }\n    }, [\n        node.id,\n        node.text\n    ]);\n    const handleTextChange = (e)=>{\n        if (!mountedRef.current) return;\n        setEditText(e.target.value);\n    };\n    const commitTextChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!mountedRef.current) return;\n        console.log(\"Committing text change:\", editText);\n        if (onTextChange && editText !== node.text) {\n            onTextChange(node.id, editText);\n        }\n        setIsEditing(false);\n        if (textRef.current) {\n            textRef.current.draggable(true); // Re-enable dragging\n        }\n    }, [\n        editText,\n        node.text,\n        node.id,\n        onTextChange\n    ]);\n    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!mountedRef.current) return;\n        // Add a small delay to prevent immediate blur when textarea is created\n        setTimeout(()=>{\n            if (isEditing && mountedRef.current) {\n                commitTextChange();\n            }\n        }, 100);\n    }, [\n        isEditing,\n        commitTextChange\n    ]);\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (!mountedRef.current) return;\n        e.stopPropagation(); // Prevent event bubbling\n        if (e.key === \"Enter\" && !e.shiftKey) {\n            e.preventDefault(); // Prevent newline\n            commitTextChange();\n        }\n        if (e.key === \"Escape\") {\n            setEditText(node.text); // Revert to original text\n            setIsEditing(false);\n            if (textRef.current) {\n                textRef.current.draggable(true);\n            }\n        }\n    }, [\n        commitTextChange,\n        node.text\n    ]);\n    const getTextAreaStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const textNode = textRef.current;\n        if (!textNode) {\n            console.log(\"TextNode \".concat(node.id, \": No text node ref available for positioning\"));\n            return {\n                display: \"none\"\n            };\n        }\n        const stage = textNode.getStage();\n        const container = stage === null || stage === void 0 ? void 0 : stage.container();\n        if (!stage || !container) {\n            console.log(\"TextNode \".concat(node.id, \": No stage or container available for positioning\"));\n            return {\n                display: \"none\"\n            };\n        }\n        // Get the bounding rect of the canvas container\n        const containerRect = container.getBoundingClientRect();\n        // Get the absolute position of the text node\n        const absPos = textNode.getAbsolutePosition();\n        const scale = stage.scaleX();\n        // Calculate the actual position relative to the page\n        const x = containerRect.left + absPos.x * scale;\n        const y = containerRect.top + absPos.y * scale;\n        const width = (node.width || textNode.width() || 100) * scale;\n        const height = (node.height || textNode.height() || 20) * scale;\n        console.log(\"TextNode \".concat(node.id, \": Positioning textarea at\"), {\n            x,\n            y,\n            width,\n            height\n        });\n        return {\n            position: \"fixed\",\n            left: \"\".concat(x, \"px\"),\n            top: \"\".concat(y, \"px\"),\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            fontSize: \"\".concat((node.fontSize || 16) * scale, \"px\"),\n            fontFamily: node.fontFamily || \"Arial\",\n            color: node.fill || \"#000000\",\n            border: \"2px solid #007bff\",\n            padding: \"2px\",\n            margin: \"0px\",\n            overflow: \"hidden\",\n            background: \"white\",\n            outline: \"none\",\n            resize: \"none\",\n            lineHeight: \"1.2\",\n            zIndex: 1000,\n            whiteSpace: \"pre-wrap\",\n            wordBreak: \"break-word\",\n            boxSizing: \"border-box\"\n        };\n    }, [\n        node\n    ]);\n    // Render the editing overlay using a portal (outside the Konva canvas)\n    const renderEditingOverlay = ()=>{\n        if (!isEditing || !portalContainer || !mountedRef.current) return null;\n        console.log(\"TextNode \".concat(node.id, \": Rendering editing overlay via portal\"));\n        try {\n            return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                ref: textAreaRef,\n                value: editText,\n                onChange: handleTextChange,\n                onBlur: handleBlur,\n                onKeyDown: handleKeyDown,\n                style: getTextAreaStyle(),\n                autoFocus: false,\n                placeholder: \"Editing...\"\n            }, void 0, false, {\n                fileName: \"/Users/lukegiraudeau/dev/exegeta/src/components/nodes/TextNode.tsx\",\n                lineNumber: 212,\n                columnNumber: 9\n            }, undefined), portalContainer);\n        } catch (error) {\n            console.error(\"TextNode \".concat(node.id, \": Error creating portal:\"), error);\n            return null;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_3__.Text, {\n                ref: textRef,\n                id: node.id,\n                x: node.x,\n                y: node.y,\n                text: node.text,\n                fontSize: node.fontSize || 16,\n                fontFamily: node.fontFamily || \"Arial\",\n                fill: node.fill || \"#000000\",\n                width: node.width,\n                height: node.height,\n                draggable: !isEditing,\n                opacity: isEditing ? 0.3 : 1,\n                onClick: handleClick,\n                onTap: handleClick,\n                onDblClick: handleDoubleClick,\n                onDragEnd: handleDragEnd,\n                stroke: node.selected ? \"#007bff\" : undefined,\n                strokeWidth: node.selected ? 2 : 0,\n                listening: !isEditing\n            }, void 0, false, {\n                fileName: \"/Users/lukegiraudeau/dev/exegeta/src/components/nodes/TextNode.tsx\",\n                lineNumber: 232,\n                columnNumber: 7\n            }, undefined),\n            renderEditingOverlay()\n        ]\n    }, void 0, true);\n};\n_s(TextNode, \"tLa1gU4iAmaU7h/1WTFWaPKJCoc=\");\n_c = TextNode;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TextNode);\nvar _c;\n$RefreshReg$(_c, \"TextNode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2NvbXBvbmVudHMvbm9kZXMvVGV4dE5vZGUudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdFO0FBQy9CO0FBQ047QUFXbkMsTUFBTU8sV0FBb0M7UUFBQyxFQUFFQyxLQUFJLEVBQUVDLFNBQVEsRUFBRUMsVUFBUyxFQUFFQyxhQUFZLEVBQUU7O0lBQ3BGLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHWiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNhLFVBQVVDLFlBQVksR0FBR2QsK0NBQVFBLENBQUNPLEtBQUtRO0lBQzlDLE1BQU1DLFVBQVVmLDZDQUFNQSxDQUFhO0lBQ25DLE1BQU1nQixjQUFjaEIsNkNBQU1BLENBQXNCO0lBQ2hELE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBd0I7SUFDdEQsTUFBTWtCLGFBQWFsQiw2Q0FBTUEsQ0FBQztJQUMxQixNQUFNLENBQUNtQixpQkFBaUJDLG1CQUFtQixHQUFHckIsK0NBQVFBLENBQXFCO0lBRTNFLDBEQUEwRDtJQUMxREUsZ0RBQVNBLENBQUM7UUFDUmlCLFdBQVdHLFVBQVU7UUFDckIseUNBQXlDO1FBQ3pDLElBQUksT0FBT0MsYUFBYSxhQUFhO1lBQ25DRixtQkFBbUJFLFNBQVNDO1FBQzlCO1FBQ0EsT0FBTztZQUNMTCxXQUFXRyxVQUFVO1FBQ3ZCO0lBQ0YsR0FBRyxFQUFFO0lBRUxwQixnREFBU0EsQ0FBQztRQUNSdUIsUUFBUUMsSUFBSSxZQUFvQixPQUFSbkIsS0FBS29CLElBQUcsMkJBQXlCaEI7UUFDekQsSUFBSUEsYUFBYVEsV0FBV0csU0FBUztZQUNuQyxnRUFBZ0U7WUFDaEUsTUFBTU0sWUFBWUMsV0FBVztnQkFDM0IsSUFBSSxDQUFDVixXQUFXRyxTQUFTO2dCQUN6QkcsUUFBUUMsSUFBSSxZQUFvQixPQUFSbkIsS0FBS29CLElBQUc7Z0JBQ2hDLElBQUlWLFlBQVlLLFdBQVcsT0FBT0wsWUFBWUssUUFBUVEsVUFBVSxZQUFZO29CQUMxRWIs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Z0JBQ1AwRSxVQUFVN0M7Z0JBQ1Y4QyxRQUFRM0M7Z0JBQ1I0QyxXQUFXM0M7Z0JBQ1g0QyxPQUFPdkM7Z0JBQ1B3QyxXQUFXO2dCQUNYQyxhQUFZOzs7OzsyQkFFZHhFO1FBRUosRUFBRSxPQUFPcUIsT0FBTztZQUNkaEIsUUFBUWdCLE1BQU0sWUFBb0IsT0FBUmxDLEtBQUtvQixJQUFHLDZCQUEyQmM7WUFDN0QsT0FBTztRQUNUO0lBQ0Y7SUFFQSxxQkFDRTs7MEJBQ0UsOERBQUNwQyw2Q0FBSUE7Z0JBQ0hpRixLQUFLdEU7Z0JBQ0xXLElBQUlwQixLQUFLb0I7Z0JBQ1RVLEdBQUc5QixLQUFLOEI7Z0JBQ1JDLEdBQUcvQixLQUFLK0I7Z0JBQ1J2QixNQUFNUixLQUFLUTtnQkFDWHFELFVBQVU3RCxLQUFLNkQsWUFBWTtnQkFDM0JDLFlBQVk5RCxLQUFLOEQsY0FBYztnQkFDL0JFLE1BQU1oRSxLQUFLZ0UsUUFBUTtnQkFDbkJOLE9BQU8xRCxLQUFLMEQ7Z0JBQ1pDLFFBQVEzRCxLQUFLMkQ7Z0JBQ2IxQixXQUFXLENBQUM3QjtnQkFDWmtGLFNBQVNsRixZQUFZLE1BQU07Z0JBQzNCbUYsU0FBUzdEO2dCQUNUOEQsT0FBTzlEO2dCQUNQK0QsWUFBWXpEO2dCQUNaOUIsV0FBV3lCO2dCQUNYK0QsUUFBUTFGLEtBQUsyRixXQUFXLFlBQVlDO2dCQUNwQ0MsYUFBYTdGLEtBQUsyRixXQUFXLElBQUk7Z0JBQ2pDRyxXQUFXLENBQUMxRjs7Ozs7O1lBRWJ5RTs7O0FBR1A7R0FsUE05RTtLQUFBQTtBQW9QTiwrREFBZUEsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9ub2Rlcy9UZXh0Tm9kZS50c3g/OTE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAncmVhY3Qta29udmEnO1xuaW1wb3J0IHsgVGV4dE5vZGUgYXMgVGV4dE5vZGVUeXBlIH0gZnJvbSAnQC90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5pbnRlcmZhY2UgVGV4dE5vZGVQcm9wcyB7XG4gIG5vZGU6IFRleHROb2RlVHlwZTtcbiAgb25TZWxlY3Q/OiAobm9kZUlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIG9uRHJhZ0VuZD86IChub2RlSWQ6IHN0cmluZywgeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uVGV4dENoYW5nZT86IChub2RlSWQ6IHN0cmluZywgbmV3VGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBUZXh0Tm9kZTogUmVhY3QuRkM8VGV4dE5vZGVQcm9wcz4gPSAoeyBub2RlLCBvblNlbGVjdCwgb25EcmFnRW5kLCBvblRleHRDaGFuZ2UgfSkgPT4ge1xuICBjb25zdCBbaXNFZGl0aW5nLCBzZXRJc0VkaXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZWRpdFRleHQsIHNldEVkaXRUZXh0XSA9IHVzZVN0YXRlKG5vZGUudGV4dCk7XG4gIGNvbnN0IHRleHRSZWYgPSB1c2VSZWY8S29udmEuVGV4dD4obnVsbCk7XG4gIGNvbnN0IHRleHRBcmVhUmVmID0gdXNlUmVmPEhUTUxUZXh0QXJlYUVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjbGlja1RpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbW91bnRlZFJlZiA9IHVzZVJlZih0cnVlKTtcbiAgY29uc3QgW3BvcnRhbENvbnRhaW5lciwgc2V0UG9ydGFsQ29udGFpbmVyXSA9IHVzZVN0YXRlPEhUTUxFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVHJhY2sgY29tcG9uZW50IG1vdW50IHN0YXRlIGFuZCBzZXQgdXAgcG9ydGFsIGNvbnRhaW5lclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYWNjZXNzIHRvIGRvY3VtZW50LmJvZHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0UG9ydGFsQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IGlzRWRpdGluZyBjaGFuZ2VkIHRvYCwgaXNFZGl0aW5nKTtcbiAgICBpZiAoaXNFZGl0aW5nICYmIG1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgLy8gVXNlIGEgbG9uZ2VyIHRpbWVvdXQgdG8gZW5zdXJlIHRoZSB0ZXh0YXJlYSBpcyBmdWxseSByZW5kZXJlZFxuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghbW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBBdHRlbXB0aW5nIHRvIGZvY3VzIHRleHRhcmVhYCk7XG4gICAgICAgIGlmICh0ZXh0QXJlYVJlZi5jdXJyZW50ICYmIHR5cGVvZiB0ZXh0QXJlYVJlZi5jdXJyZW50LmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGV4dEFyZWFSZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgIHRleHRBcmVhUmVmLmN1cnJlbnQuc2VsZWN0KCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IFRleHRhcmVhIGZvY3VzZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IFRleHRhcmVhIHJlZiBub3QgYXZhaWxhYmxlIG9yIGZvY3VzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gIH0sIFtpc0VkaXRpbmcsIG5vZGUuaWRdKTtcblxuICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgVGV4dE5vZGUgJHtub2RlLmlkfTogU2luZ2xlIGNsaWNrIGRldGVjdGVkLCBpc0VkaXRpbmc6YCwgaXNFZGl0aW5nKTtcbiAgICBpZiAoaXNFZGl0aW5nIHx8ICFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxuICAgIGlmIChjbGlja1RpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNsaWNrVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsaWNrVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IGEgdGltZW91dCBmb3Igc2luZ2xlIGNsaWNrIGFjdGlvblxuICAgIGNsaWNrVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIW1vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IFByb2Nlc3Npbmcgc2luZ2xlIGNsaWNrYCk7XG4gICAgICBvblNlbGVjdD8uKG5vZGUuaWQpO1xuICAgIH0sIDIwMCk7XG4gIH0sIFtub2RlLmlkLCBpc0VkaXRpbmcsIG9uU2VsZWN0XSk7XG5cbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IHVzZUNhbGxiYWNrKChlOiBLb252YS5Lb252YUV2ZW50T2JqZWN0PERyYWdFdmVudD4pID0+IHtcbiAgICBjb25zb2xlLmxvZyhgVGV4dE5vZGUgJHtub2RlLmlkfTogRHJhZyBlbmQgZGV0ZWN0ZWRgKTtcbiAgICBpZiAoaXNFZGl0aW5nIHx8ICFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBvbkRyYWdFbmQ/Lihub2RlLmlkLCBlLnRhcmdldC54KCksIGUudGFyZ2V0LnkoKSk7XG4gIH0sIFtub2RlLmlkLCBpc0VkaXRpbmcsIG9uRHJhZ0VuZF0pO1xuXG4gIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBEb3VibGUgY2xpY2sgZGV0ZWN0ZWQsIHN0YXJ0aW5nIGVkaXQgbW9kZWApO1xuICAgIFxuICAgIGlmICghbW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhgVGV4dE5vZGUgJHtub2RlLmlkfTogQ29tcG9uZW50IG5vdCBtb3VudGVkLCBza2lwcGluZyBlZGl0IG1vZGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgc2luZ2xlIGNsaWNrIHRpbWVvdXRcbiAgICBpZiAoY2xpY2tUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGlja1RpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBzZXRFZGl0VGV4dChub2RlLnRleHQpOyAvLyBJbml0aWFsaXplIHdpdGggY3VycmVudCB0ZXh0XG4gICAgICBzZXRJc0VkaXRpbmcodHJ1ZSk7XG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGRyYWdnaW5nIG9uIHRoZSBLb252YS5UZXh0IG5vZGUgaXRzZWxmXG4gICAgICBpZiAodGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHRleHRSZWYuY3VycmVudC5kcmFnZ2FibGUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBFcnJvciBzZXR0aW5nIGVkaXQgbW9kZTpgLCBlcnJvcik7XG4gICAgfVxuICB9LCBbbm9kZS5pZCwgbm9kZS50ZXh0XSk7XG5cbiAgY29uc3QgaGFuZGxlVGV4dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIGlmICghbW91bnRlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgc2V0RWRpdFRleHQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IGNvbW1pdFRleHRDaGFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zb2xlLmxvZygnQ29tbWl0dGluZyB0ZXh0IGNoYW5nZTonLCBlZGl0VGV4dCk7XG4gICAgaWYgKG9uVGV4dENoYW5nZSAmJiBlZGl0VGV4dCAhPT0gbm9kZS50ZXh0KSB7XG4gICAgICBvblRleHRDaGFuZ2Uobm9kZS5pZCwgZWRpdFRleHQpO1xuICAgIH1cbiAgICBzZXRJc0VkaXRpbmcoZmFsc2UpO1xuICAgIGlmICh0ZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgIHRleHRSZWYuY3VycmVudC5kcmFnZ2FibGUodHJ1ZSk7IC8vIFJlLWVuYWJsZSBkcmFnZ2luZ1xuICAgIH1cbiAgfSwgW2VkaXRUZXh0LCBub2RlLnRleHQsIG5vZGUuaWQsIG9uVGV4dENoYW5nZV0pO1xuXG4gIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBwcmV2ZW50IGltbWVkaWF0ZSBibHVyIHdoZW4gdGV4dGFyZWEgaXMgY3JlYXRlZFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGlzRWRpdGluZyAmJiBtb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29tbWl0VGV4dENoYW5nZSgpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH0sIFtpc0VkaXRpbmcsIGNvbW1pdFRleHRDaGFuZ2VdKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4pID0+IHtcbiAgICBpZiAoIW1vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnQgZXZlbnQgYnViYmxpbmdcbiAgICBcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBuZXdsaW5lXG4gICAgICBjb21taXRUZXh0Q2hhbmdlKCk7XG4gICAgfVxuICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgIHNldEVkaXRUZXh0KG5vZGUudGV4dCk7IC8vIFJldmVydCB0byBvcmlnaW5hbCB0ZXh0XG4gICAgICBzZXRJc0VkaXRpbmcoZmFsc2UpO1xuICAgICAgaWYgKHRleHRSZWYuY3VycmVudCkge1xuICAgICAgICB0ZXh0UmVmLmN1cnJlbnQuZHJhZ2dhYmxlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2NvbW1pdFRleHRDaGFuZ2UsIG5vZGUudGV4dF0pO1xuXG4gIGNvbnN0IGdldFRleHRBcmVhU3R5bGUgPSB1c2VDYWxsYmFjaygoKTogUmVhY3QuQ1NTUHJvcGVydGllcyA9PiB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSB0ZXh0UmVmLmN1cnJlbnQ7XG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IE5vIHRleHQgbm9kZSByZWYgYXZhaWxhYmxlIGZvciBwb3NpdGlvbmluZ2ApO1xuICAgICAgcmV0dXJuIHsgZGlzcGxheTogJ25vbmUnIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhZ2UgPSB0ZXh0Tm9kZS5nZXRTdGFnZSgpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN0YWdlPy5jb250YWluZXIoKTtcbiAgICBcbiAgICBpZiAoIXN0YWdlIHx8ICFjb250YWluZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBUZXh0Tm9kZSAke25vZGUuaWR9OiBObyBzdGFnZSBvciBjb250YWluZXIgYXZhaWxhYmxlIGZvciBwb3NpdGlvbmluZ2ApO1xuICAgICAgcmV0dXJuIHsgZGlzcGxheTogJ25vbmUnIH07XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBjYW52YXMgY29udGFpbmVyXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IG5vZGVcbiAgICBjb25zdCBhYnNQb3MgPSB0ZXh0Tm9kZS5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc2NhbGUgPSBzdGFnZS5zY2FsZVgoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFnZVxuICAgIGNvbnN0IHggPSBjb250YWluZXJSZWN0LmxlZnQgKyBhYnNQb3MueCAqIHNjYWxlO1xuICAgIGNvbnN0IHkgPSBjb250YWluZXJSZWN0LnRvcCArIGFic1Bvcy55ICogc2NhbGU7XG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSAobm9kZS53aWR0aCB8fCB0ZXh0Tm9kZS53aWR0aCgpIHx8IDEwMCkgKiBzY2FsZTtcbiAgICBjb25zdCBoZWlnaHQgPSAobm9kZS5oZWlnaHQgfHwgdGV4dE5vZGUuaGVpZ2h0KCkgfHwgMjApICogc2NhbGU7XG5cbiAgICBjb25zb2xlLmxvZyhgVGV4dE5vZGUgJHtub2RlLmlkfTogUG9zaXRpb25pbmcgdGV4dGFyZWEgYXRgLCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsIC8vIFVzZSBmaXhlZCBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgbGVmdDogYCR7eH1weGAsXG4gICAgICB0b3A6IGAke3l9cHhgLFxuICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YCxcbiAgICAgIGZvbnRTaXplOiBgJHsobm9kZS5mb250U2l6ZSB8fCAxNikgKiBzY2FsZX1weGAsXG4gICAgICBmb250RmFtaWx5OiBub2RlLmZvbnRGYW1pbHkgfHwgJ0FyaWFsJyxcbiAgICAgIGNvbG9yOiBub2RlLmZpbGwgfHwgJyMwMDAwMDAnLFxuICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICMwMDdiZmYnLFxuICAgICAgcGFkZGluZzogJzJweCcsXG4gICAgICBtYXJnaW46ICcwcHgnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgYmFja2dyb3VuZDogJ3doaXRlJyxcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgbGluZUhlaWdodDogJzEuMicsXG4gICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgd29yZEJyZWFrOiAnYnJlYWstd29yZCcsXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB9O1xuICB9LCBbbm9kZV0pO1xuXG4gIC8vIFJlbmRlciB0aGUgZWRpdGluZyBvdmVybGF5IHVzaW5nIGEgcG9ydGFsIChvdXRzaWRlIHRoZSBLb252YSBjYW52YXMpXG4gIGNvbnN0IHJlbmRlckVkaXRpbmdPdmVybGF5ID0gKCkgPT4ge1xuICAgIGlmICghaXNFZGl0aW5nIHx8ICFwb3J0YWxDb250YWluZXIgfHwgIW1vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFRleHROb2RlICR7bm9kZS5pZH06IFJlbmRlcmluZyBlZGl0aW5nIG92ZXJsYXkgdmlhIHBvcnRhbGApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKFxuICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICByZWY9e3RleHRBcmVhUmVmfVxuICAgICAgICAgIHZhbHVlPXtlZGl0VGV4dH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlVGV4dENoYW5nZX1cbiAgICAgICAgICBvbkJsdXI9e2hhbmRsZUJsdXJ9XG4gICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICAgIHN0eWxlPXtnZXRUZXh0QXJlYVN0eWxlKCl9XG4gICAgICAgICAgYXV0b0ZvY3VzPXtmYWxzZX0gLy8gV2UnbGwgaGFuZGxlIGZvY3VzIG1hbnVhbGx5XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJFZGl0aW5nLi4uXCJcbiAgICAgICAgLz4sXG4gICAgICAgIHBvcnRhbENvbnRhaW5lclxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgVGV4dE5vZGUgJHtub2RlLmlkfTogRXJyb3IgY3JlYXRpbmcgcG9ydGFsOmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8VGV4dFxuICAgICAgICByZWY9e3RleHRSZWZ9XG4gICAgICAgIGlkPXtub2RlLmlkfVxuICAgICAgICB4PXtub2RlLnh9XG4gICAgICAgIHk9e25vZGUueX1cbiAgICAgICAgdGV4dD17bm9kZS50ZXh0fVxuICAgICAgICBmb250U2l6ZT17bm9kZS5mb250U2l6ZSB8fCAxNn1cbiAgICAgICAgZm9udEZhbWlseT17bm9kZS5mb250RmFtaWx5IHx8ICdBcmlhbCd9XG4gICAgICAgIGZpbGw9e25vZGUuZmlsbCB8fCAnIzAwMDAwMCd9XG4gICAgICAgIHdpZHRoPXtub2RlLndpZHRofVxuICAgICAgICBoZWlnaHQ9e25vZGUuaGVpZ2h0fVxuICAgICAgICBkcmFnZ2FibGU9eyFpc0VkaXRpbmd9IC8vIE9ubHkgZHJhZ2dhYmxlIHdoZW4gbm90IGVkaXRpbmdcbiAgICAgICAgb3BhY2l0eT17aXNFZGl0aW5nID8gMC4zIDogMX0gLy8gTWFrZSBpdCBzZW1pLXRyYW5zcGFyZW50IHdoZW4gZWRpdGluZ1xuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgb25UYXA9e2hhbmRsZUNsaWNrfSAvLyBGb3IgdG91Y2ggZGV2aWNlc1xuICAgICAgICBvbkRibENsaWNrPXtoYW5kbGVEb3VibGVDbGlja31cbiAgICAgICAgb25EcmFnRW5kPXtoYW5kbGVEcmFnRW5kfVxuICAgICAgICBzdHJva2U9e25vZGUuc2VsZWN0ZWQgPyAnIzAwN2JmZicgOiB1bmRlZmluZWR9XG4gICAgICAgIHN0cm9rZVdpZHRoPXtub2RlLnNlbGVjdGVkID8gMiA6IDB9XG4gICAgICAgIGxpc3RlbmluZz17IWlzRWRpdGluZ30gLy8gRG9uJ3QgbGlzdGVuIHRvIGV2ZW50cyB3aGVuIGVkaXRpbmdcbiAgICAgIC8+XG4gICAgICB7cmVuZGVyRWRpdGluZ092ZXJsYXkoKX1cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRleHROb2RlOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiY3JlYXRlUG9ydGFsIiwiVGV4dCIsIlRleHROb2RlIiwibm9kZSIsIm9uU2VsZWN0Iiwib25EcmFnRW5kIiwib25UZXh0Q2hhbmdlIiwiaXNFZGl0aW5nIiwic2V0SXNFZGl0aW5nIiwiZWRpdFRleHQiLCJzZXRFZGl0VGV4dCIsInRleHQiLCJ0ZXh0UmVmIiwidGV4dEFyZWFSZWYiLCJjbGlja1RpbWVvdXRSZWYiLCJtb3VudGVkUmVmIiwicG9ydGFsQ29udGFpbmVyIiwic2V0UG9ydGFsQ29udGFpbmVyIiwiY3VycmVudCIsImRvY3VtZW50IiwiYm9keSIsImNvbnNvbGUiLCJsb2ciLCJpZCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJmb2N1cyIsInNlbGVjdCIsImNsZWFyVGltZW91dCIsImhhbmRsZUNsaWNrIiwiaGFuZGxlRHJhZ0VuZCIsImUiLCJ0YXJnZXQiLCJ4IiwieSIsImhhbmRsZURvdWJsZUNsaWNrIiwiZHJhZ2dhYmxlIiwiZXJyb3IiLCJoYW5kbGVUZXh0Q2hhbmdlIiwidmFsdWUiLCJjb21taXRUZXh0Q2hhbmdlIiwiaGFuZGxlQmx1ciIsImhhbmRsZUtleURvd24iLCJzdG9wUHJvcGFnYXRpb24iLCJrZXkiLCJzaGlmdEtleSIsInByZXZlbnREZWZhdWx0IiwiZ2V0VGV4dEFyZWFTdHlsZSIsInRleHROb2RlIiwiZGlzcGxheSIsInN0YWdlIiwiZ2V0U3RhZ2UiLCJjb250YWluZXIiLCJjb250YWluZXJSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYWJzUG9zIiwiZ2V0QWJzb2x1dGVQb3NpdGlvbiIsInNjYWxlIiwic2NhbGVYIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjb2xvciIsImZpbGwiLCJib3JkZXIiLCJwYWRkaW5nIiwibWFyZ2luIiwib3ZlcmZsb3ciLCJiYWNrZ3JvdW5kIiwib3V0bGluZSIsInJlc2l6ZSIsImxpbmVIZWlnaHQiLCJ6SW5kZXgiLCJ3aGl0ZVNwYWNlIiwid29yZEJyZWFrIiwiYm94U2l6aW5nIiwicmVuZGVyRWRpdGluZ092ZXJsYXkiLCJ0ZXh0YXJlYSIsInJlZiIsIm9uQ2hhbmdlIiwib25CbHVyIiwib25LZXlEb3duIiwic3R5bGUiLCJhdXRvRm9jdXMiLCJwbGFjZWhvbGRlciIsIm9wYWNpdHkiLCJvbkNsaWNrIiwib25UYXAiLCJvbkRibENsaWNrIiwic3Ryb2tlIiwic2VsZWN0ZWQiLCJ1bmRlZmluZWQiLCJzdHJva2VXaWR0aCIsImxpc3RlbmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./src/components/nodes/TextNode.tsx\n"));

/***/ })

});